{"version":3,"file":"nivo-line.umd.js","sources":["../src/PointTooltip.js","../src/SliceTooltip.js","../src/props.js","../src/hooks.js","../src/Areas.js","../src/LinesItem.js","../src/Lines.js","../src/SlicesItem.js","../src/Slices.js","../src/Points.js","../src/Mesh.js","../src/Line.js","../src/LineCanvas.js","../src/ResponsiveLineCanvas.js","../src/ResponsiveLine.js"],"sourcesContent":["/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport { BasicTooltip } from '@nivo/tooltip'\n\nconst LinePointTooltip = ({ point }) => {\n    return (\n        <BasicTooltip\n            id={\n                <span>\n                    x: <strong>{point.data.xFormatted}</strong>, y:{' '}\n                    <strong>{point.data.yFormatted}</strong>\n                </span>\n            }\n            enableChip={true}\n            color={point.serieColor}\n        />\n    )\n}\n\nLinePointTooltip.propTypes = {\n    point: PropTypes.object.isRequired,\n}\n\nexport default memo(LinePointTooltip)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport { useTheme } from '@nivo/core'\nimport { Chip, TableTooltip } from '@nivo/tooltip'\n\nconst SliceTooltip = ({ slice, axis }) => {\n    const theme = useTheme()\n    const otherAxis = axis === 'x' ? 'y' : 'x'\n\n    return (\n        <TableTooltip\n            rows={slice.points.map(point => [\n                <Chip key=\"chip\" color={point.serieColor} style={theme.tooltip.chip} />,\n                point.serieId,\n                <span key=\"value\" style={theme.tooltip.tableCellValue}>\n                    {point.data[`${otherAxis}Formatted`]}\n                </span>,\n            ])}\n        />\n    )\n}\n\nSliceTooltip.propTypes = {\n    slice: PropTypes.object.isRequired,\n    axis: PropTypes.oneOf(['x', 'y']).isRequired,\n}\n\nexport default memo(SliceTooltip)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport PropTypes from 'prop-types'\nimport { lineCurvePropType, blendModePropType, motionPropTypes, defsPropTypes } from '@nivo/core'\nimport { ordinalColorsPropType } from '@nivo/colors'\nimport { axisPropType } from '@nivo/axes'\nimport { LegendPropShape } from '@nivo/legends'\nimport PointTooltip from './PointTooltip'\nimport SliceTooltip from './SliceTooltip'\n\nconst commonPropTypes = {\n    data: PropTypes.arrayOf(\n        PropTypes.shape({\n            id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,\n            data: PropTypes.arrayOf(\n                PropTypes.shape({\n                    x: PropTypes.oneOfType([\n                        PropTypes.number,\n                        PropTypes.string,\n                        PropTypes.instanceOf(Date),\n                    ]),\n                    y: PropTypes.oneOfType([\n                        PropTypes.number,\n                        PropTypes.string,\n                        PropTypes.instanceOf(Date),\n                    ]),\n                })\n            ).isRequired,\n        })\n    ).isRequired,\n\n    xScale: PropTypes.object.isRequired,\n    xFormat: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n    yScale: PropTypes.object.isRequired,\n    yFormat: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n\n    layers: PropTypes.arrayOf(\n        PropTypes.oneOfType([\n            PropTypes.oneOf([\n                'grid',\n                'markers',\n                'axes',\n                'areas',\n                'crosshair',\n                'lines',\n                'slices',\n                'points',\n                'mesh',\n                'legends',\n            ]),\n            PropTypes.func,\n        ])\n    ).isRequired,\n\n    curve: lineCurvePropType.isRequired,\n\n    axisTop: axisPropType,\n    axisRight: axisPropType,\n    axisBottom: axisPropType,\n    axisLeft: axisPropType,\n\n    enableGridX: PropTypes.bool.isRequired,\n    enableGridY: PropTypes.bool.isRequired,\n    gridXValues: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.arrayOf(\n            PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)])\n        ),\n    ]),\n    gridYValues: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.arrayOf(\n            PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)])\n        ),\n    ]),\n\n    enablePoints: PropTypes.bool.isRequired,\n    pointSymbol: PropTypes.func,\n    pointSize: PropTypes.number.isRequired,\n    pointColor: PropTypes.any.isRequired,\n    pointBorderWidth: PropTypes.number.isRequired,\n    pointBorderColor: PropTypes.any.isRequired,\n    enablePointLabel: PropTypes.bool.isRequired,\n    pointLabel: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n\n    markers: PropTypes.arrayOf(\n        PropTypes.shape({\n            axis: PropTypes.oneOf(['x', 'y']).isRequired,\n            value: PropTypes.oneOfType([\n                PropTypes.number,\n                PropTypes.string,\n                PropTypes.instanceOf(Date),\n            ]).isRequired,\n            style: PropTypes.object,\n        })\n    ),\n\n    colors: ordinalColorsPropType.isRequired,\n\n    enableArea: PropTypes.bool.isRequired,\n    areaOpacity: PropTypes.number.isRequired,\n    areaBlendMode: blendModePropType.isRequired,\n    areaBaselineValue: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.string,\n        PropTypes.instanceOf(Date),\n    ]).isRequired,\n    lineWidth: PropTypes.number.isRequired,\n\n    legends: PropTypes.arrayOf(PropTypes.shape(LegendPropShape)).isRequired,\n\n    isInteractive: PropTypes.bool.isRequired,\n    debugMesh: PropTypes.bool.isRequired,\n\n    tooltip: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,\n\n    enableSlices: PropTypes.oneOf(['x', 'y', false]).isRequired,\n    debugSlices: PropTypes.bool.isRequired,\n    sliceTooltip: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,\n\n    enableCrosshair: PropTypes.bool.isRequired,\n    crosshairType: PropTypes.string.isRequired,\n}\n\nexport const LinePropTypes = {\n    ...commonPropTypes,\n    enablePointLabel: PropTypes.bool.isRequired,\n    role: PropTypes.string.isRequired,\n    useMesh: PropTypes.bool.isRequired,\n    ...motionPropTypes,\n    ...defsPropTypes,\n}\n\nexport const LineCanvasPropTypes = {\n    pixelRatio: PropTypes.number.isRequired,\n    ...commonPropTypes,\n}\n\nconst commonDefaultProps = {\n    curve: 'linear',\n\n    xScale: {\n        type: 'point',\n    },\n    yScale: {\n        type: 'linear',\n        min: 0,\n        max: 'auto',\n    },\n\n    layers: [\n        'grid',\n        'markers',\n        'axes',\n        'areas',\n        'crosshair',\n        'lines',\n        'points',\n        'slices',\n        'mesh',\n        'legends',\n    ],\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: true,\n    enableGridY: true,\n\n    enablePoints: true,\n    pointSize: 6,\n    pointColor: { from: 'color' },\n    pointBorderWidth: 0,\n    pointBorderColor: { theme: 'background' },\n    enablePointLabel: false,\n    pointLabel: 'yFormatted',\n\n    colors: { scheme: 'nivo' },\n    enableArea: false,\n    areaBaselineValue: 0,\n    areaOpacity: 0.2,\n    areaBlendMode: 'normal',\n    lineWidth: 2,\n\n    legends: [],\n\n    isInteractive: true,\n    tooltip: PointTooltip,\n    enableSlices: false,\n    debugSlices: false,\n    sliceTooltip: SliceTooltip,\n    debugMesh: false,\n    enableCrosshair: true,\n    crosshairType: 'bottom-left',\n}\n\nexport const LineDefaultProps = {\n    ...commonDefaultProps,\n    enablePointLabel: false,\n    useMesh: false,\n    animate: true,\n    motionConfig: 'gentle',\n    defs: [],\n    fill: [],\n    role: 'img',\n}\n\nexport const LineCanvasDefaultProps = {\n    ...commonDefaultProps,\n    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { useCallback, useMemo, useState } from 'react'\nimport { area, line } from 'd3-shape'\nimport { curveFromProp, useTheme, useValueFormatter } from '@nivo/core'\nimport { useOrdinalColorScale, useInheritedColor } from '@nivo/colors'\nimport { computeXYScalesForSeries } from '@nivo/scales'\nimport { LineDefaultProps } from './props'\n\nexport const useLineGenerator = ({ curve }) => {\n    return useMemo(\n        () =>\n            line()\n                .defined(d => d.x !== null && d.y !== null)\n                .x(d => d.x)\n                .y(d => d.y)\n                .curve(curveFromProp(curve)),\n        [curve]\n    )\n}\n\nexport const useAreaGenerator = ({ curve, yScale, areaBaselineValue }) => {\n    return useMemo(() => {\n        return area()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y1(d => d.y)\n            .curve(curveFromProp(curve))\n            .y0(yScale(areaBaselineValue))\n    }, [curve, yScale, areaBaselineValue])\n}\n\nconst usePoints = ({ series, getPointColor, getPointBorderColor, formatX, formatY }) => {\n    return useMemo(() => {\n        return series.reduce((acc, serie) => {\n            return [\n                ...acc,\n                ...serie.data\n                    .filter(datum => datum.position.x !== null && datum.position.y !== null)\n                    .map((datum, i) => {\n                        const point = {\n                            id: `${serie.id}.${i}`,\n                            index: acc.length + i,\n                            serieId: serie.id,\n                            serieColor: serie.color,\n                            x: datum.position.x,\n                            y: datum.position.y,\n                        }\n                        point.color = getPointColor(serie)\n                        point.borderColor = getPointBorderColor(point)\n                        point.data = {\n                            ...datum.data,\n                            xFormatted: formatX(datum.data.x),\n                            yFormatted: formatY(datum.data.y),\n                        }\n\n                        return point\n                    }),\n            ]\n        }, [])\n    }, [series, getPointColor, getPointBorderColor, formatX, formatY])\n}\n\nexport const useSlices = ({ enableSlices, points, width, height }) => {\n    return useMemo(() => {\n        if (enableSlices === false) return []\n\n        if (enableSlices === 'x') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.x)) map.set(point.x, [point])\n                else map.get(point.x).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([x, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let x0\n                    if (!prevSlice) x0 = x\n                    else x0 = x - (x - prevSlice[0]) / 2\n\n                    let sliceWidth\n                    if (!nextSlice) sliceWidth = width - x0\n                    else sliceWidth = x - x0 + (nextSlice[0] - x) / 2\n\n                    return {\n                        id: x,\n                        x0,\n                        x,\n                        y0: 0,\n                        y: 0,\n                        width: sliceWidth,\n                        height,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        } else if (enableSlices === 'y') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.y)) map.set(point.y, [point])\n                else map.get(point.y).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([y, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let y0\n                    if (!prevSlice) y0 = y\n                    else y0 = y - (y - prevSlice[0]) / 2\n\n                    let sliceHeight\n                    if (!nextSlice) sliceHeight = height - y0\n                    else sliceHeight = y - y0 + (nextSlice[0] - y) / 2\n\n                    return {\n                        id: y,\n                        x0: 0,\n                        x: 0,\n                        y0,\n                        y,\n                        width,\n                        height: sliceHeight,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        }\n    }, [enableSlices, points])\n}\n\nexport const useLine = ({\n    data,\n    xScale: xScaleSpec = LineDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = LineDefaultProps.yScale,\n    yFormat,\n    width,\n    height,\n    colors = LineDefaultProps.colors,\n    curve = LineDefaultProps.curve,\n    areaBaselineValue = LineDefaultProps.areaBaselineValue,\n    pointColor = LineDefaultProps.pointColor,\n    pointBorderColor = LineDefaultProps.pointBorderColor,\n    enableSlices = LineDefaultProps.enableSlicesTooltip,\n}) => {\n    const formatX = useValueFormatter(xFormat)\n    const formatY = useValueFormatter(yFormat)\n    const getColor = useOrdinalColorScale(colors, 'id')\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n    const [hiddenIds, setHiddenIds] = useState([])\n\n    const {\n        xScale,\n        yScale,\n        series: rawSeries,\n    } = useMemo(\n        () =>\n            computeXYScalesForSeries(\n                data.filter(item => hiddenIds.indexOf(item.id) === -1),\n                xScaleSpec,\n                yScaleSpec,\n                width,\n                height\n            ),\n        [data, hiddenIds, xScaleSpec, yScaleSpec, width, height]\n    )\n\n    const { legendData, series } = useMemo(() => {\n        const dataWithColor = data.map(line => ({\n            id: line.id,\n            label: line.id,\n            color: getColor(line),\n        }))\n        const series = dataWithColor\n            .map(datum => ({\n                ...rawSeries.find(serie => serie.id === datum.id),\n                color: datum.color,\n            }))\n            .filter(item => Boolean(item.id))\n        const legendData = dataWithColor\n            .map(item => ({ ...item, hidden: !series.find(serie => serie.id === item.id) }))\n            .reverse()\n\n        return { legendData, series }\n    }, [data, rawSeries, getColor])\n\n    const toggleSerie = useCallback(id => {\n        setHiddenIds(state =>\n            state.indexOf(id) > -1 ? state.filter(item => item !== id) : [...state, id]\n        )\n    }, [])\n\n    const points = usePoints({\n        series,\n        getPointColor,\n        getPointBorderColor,\n        formatX,\n        formatY,\n    })\n\n    const slices = useSlices({\n        enableSlices,\n        points,\n        width,\n        height,\n    })\n\n    const lineGenerator = useLineGenerator({ curve })\n    const areaGenerator = useAreaGenerator({\n        curve,\n        yScale,\n        areaBaselineValue,\n    })\n\n    return {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        getColor,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    }\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig, blendModePropType } from '@nivo/core'\n\nconst AreaPath = ({ areaBlendMode, areaOpacity, color, fill, path }) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedPath = useAnimatedPath(path)\n    const animatedProps = useSpring({\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={fill ? fill : animatedProps.color}\n            fillOpacity={areaOpacity}\n            strokeWidth={0}\n            style={{\n                mixBlendMode: areaBlendMode,\n            }}\n        />\n    )\n}\n\nAreaPath.propTypes = {\n    areaBlendMode: blendModePropType.isRequired,\n    areaOpacity: PropTypes.number.isRequired,\n    color: PropTypes.string,\n    fill: PropTypes.string,\n    path: PropTypes.string.isRequired,\n}\n\nconst Areas = ({ areaGenerator, areaOpacity, areaBlendMode, lines }) => {\n    const computedLines = lines.slice(0).reverse()\n\n    return (\n        <g>\n            {computedLines.map(line => (\n                <AreaPath\n                    key={line.id}\n                    path={areaGenerator(line.data.map(d => d.position))}\n                    {...{ areaOpacity, areaBlendMode, ...line }}\n                />\n            ))}\n        </g>\n    )\n}\n\nAreas.propTypes = {\n    areaGenerator: PropTypes.func.isRequired,\n    areaOpacity: PropTypes.number.isRequired,\n    areaBlendMode: blendModePropType.isRequired,\n    lines: PropTypes.arrayOf(PropTypes.object).isRequired,\n}\n\nexport default memo(Areas)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo, useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath } from '@nivo/core'\n\nconst LinesItem = ({ lineGenerator, points, color, thickness }) => {\n    const path = useMemo(() => lineGenerator(points), [lineGenerator, points])\n    const animatedPath = useAnimatedPath(path)\n\n    return <animated.path d={animatedPath} fill=\"none\" strokeWidth={thickness} stroke={color} />\n}\n\nLinesItem.propTypes = {\n    points: PropTypes.arrayOf(\n        PropTypes.shape({\n            x: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n            y: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n        })\n    ),\n    lineGenerator: PropTypes.func.isRequired,\n    color: PropTypes.string.isRequired,\n    thickness: PropTypes.number.isRequired,\n}\n\nexport default memo(LinesItem)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport LinesItem from './LinesItem'\n\nconst Lines = ({ lines, lineGenerator, lineWidth }) => {\n    return lines\n        .slice(0)\n        .reverse()\n        .map(({ id, data, color }) => (\n            <LinesItem\n                key={id}\n                id={id}\n                points={data.map(d => d.position)}\n                lineGenerator={lineGenerator}\n                color={color}\n                thickness={lineWidth}\n            />\n        ))\n}\n\nLines.propTypes = {\n    lines: PropTypes.arrayOf(\n        PropTypes.shape({\n            id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,\n            color: PropTypes.string.isRequired,\n            data: PropTypes.arrayOf(\n                PropTypes.shape({\n                    data: PropTypes.shape({\n                        x: PropTypes.oneOfType([\n                            PropTypes.string,\n                            PropTypes.number,\n                            PropTypes.instanceOf(Date),\n                        ]),\n                        y: PropTypes.oneOfType([\n                            PropTypes.string,\n                            PropTypes.number,\n                            PropTypes.instanceOf(Date),\n                        ]),\n                    }).isRequired,\n                    position: PropTypes.shape({\n                        x: PropTypes.number,\n                        y: PropTypes.number,\n                    }).isRequired,\n                })\n            ).isRequired,\n        })\n    ).isRequired,\n    lineWidth: PropTypes.number.isRequired,\n    lineGenerator: PropTypes.func.isRequired,\n}\n\nexport default memo(Lines)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { createElement, memo, useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { useTooltip } from '@nivo/tooltip'\n\nconst SlicesItem = ({ slice, axis, debug, tooltip, isCurrent, setCurrent }) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n        },\n        [showTooltipFromEvent, tooltip, slice]\n    )\n\n    const handleMouseMove = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n        },\n        [showTooltipFromEvent, tooltip, slice]\n    )\n\n    const handleMouseLeave = useCallback(() => {\n        hideTooltip()\n        setCurrent(null)\n    }, [hideTooltip])\n\n    return (\n        <rect\n            x={slice.x0}\n            y={slice.y0}\n            width={slice.width}\n            height={slice.height}\n            stroke=\"red\"\n            strokeWidth={debug ? 1 : 0}\n            strokeOpacity={0.75}\n            fill=\"red\"\n            fillOpacity={isCurrent && debug ? 0.35 : 0}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n        />\n    )\n}\n\nSlicesItem.propTypes = {\n    slice: PropTypes.object.isRequired,\n    axis: PropTypes.oneOf(['x', 'y']).isRequired,\n    debug: PropTypes.bool.isRequired,\n    height: PropTypes.number.isRequired,\n    tooltip: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),\n    isCurrent: PropTypes.bool.isRequired,\n    setCurrent: PropTypes.func.isRequired,\n}\n\nexport default memo(SlicesItem)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport SlicesItem from './SlicesItem'\n\nconst Slices = ({ slices, axis, debug, height, tooltip, current, setCurrent }) => {\n    return slices.map(slice => (\n        <SlicesItem\n            key={slice.id}\n            slice={slice}\n            axis={axis}\n            debug={debug}\n            height={height}\n            tooltip={tooltip}\n            setCurrent={setCurrent}\n            isCurrent={current !== null && current.id === slice.id}\n        />\n    ))\n}\n\nSlices.propTypes = {\n    slices: PropTypes.arrayOf(\n        PropTypes.shape({\n            id: PropTypes.oneOfType([\n                PropTypes.number,\n                PropTypes.string,\n                PropTypes.instanceOf(Date),\n            ]).isRequired,\n            x: PropTypes.number.isRequired,\n            y: PropTypes.number.isRequired,\n            points: PropTypes.arrayOf(PropTypes.object).isRequired,\n        })\n    ).isRequired,\n    axis: PropTypes.oneOf(['x', 'y']).isRequired,\n    debug: PropTypes.bool.isRequired,\n    height: PropTypes.number.isRequired,\n    tooltip: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,\n    current: PropTypes.object,\n    setCurrent: PropTypes.func.isRequired,\n}\n\nexport default memo(Slices)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport { getLabelGenerator, DotsItem, useTheme } from '@nivo/core'\n\nconst Points = ({ points, symbol, size, borderWidth, enableLabel, label, labelYOffset }) => {\n    const theme = useTheme()\n    const getLabel = getLabelGenerator(label)\n\n    /**\n     * We reverse the `points` array so that points from the lower lines in stacked lines\n     * graph are drawn on top. See https://github.com/plouc/nivo/issues/1051.\n     */\n    const mappedPoints = points\n        .slice(0)\n        .reverse()\n        .map(point => {\n            const mappedPoint = {\n                id: point.id,\n                x: point.x,\n                y: point.y,\n                datum: point.data,\n                fill: point.color,\n                stroke: point.borderColor,\n                label: enableLabel ? getLabel(point.data) : null,\n            }\n\n            return mappedPoint\n        })\n\n    return (\n        <g>\n            {mappedPoints.map(point => (\n                <DotsItem\n                    key={point.id}\n                    x={point.x}\n                    y={point.y}\n                    datum={point.datum}\n                    symbol={symbol}\n                    size={size}\n                    color={point.fill}\n                    borderWidth={borderWidth}\n                    borderColor={point.stroke}\n                    label={point.label}\n                    labelYOffset={labelYOffset}\n                    theme={theme}\n                />\n            ))}\n        </g>\n    )\n}\n\nPoints.propTypes = {\n    points: PropTypes.arrayOf(PropTypes.object),\n    symbol: PropTypes.func,\n    size: PropTypes.number.isRequired,\n    color: PropTypes.func.isRequired,\n    borderWidth: PropTypes.number.isRequired,\n    borderColor: PropTypes.func.isRequired,\n    enableLabel: PropTypes.bool.isRequired,\n    label: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n    labelYOffset: PropTypes.number,\n}\n\nexport default memo(Points)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { createElement, memo, useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { useTooltip } from '@nivo/tooltip'\nimport { Mesh as BaseMesh } from '@nivo/voronoi'\n\nconst Mesh = ({\n    points,\n    width,\n    height,\n    margin,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    tooltip,\n    debug,\n}) => {\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            setCurrent(point)\n            onMouseEnter && onMouseEnter(point, event)\n        },\n        [setCurrent, showTooltipAt, tooltip, onMouseEnter, margin]\n    )\n\n    const handleMouseMove = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            setCurrent(point)\n            onMouseMove && onMouseMove(point, event)\n        },\n        [setCurrent, showTooltipAt, tooltip, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (point, event) => {\n            hideTooltip()\n            setCurrent(null)\n            onMouseLeave && onMouseLeave(point, event)\n        },\n        [hideTooltip, setCurrent, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        (point, event) => {\n            onClick && onClick(point, event)\n        },\n        [onClick]\n    )\n\n    return (\n        <BaseMesh\n            nodes={points}\n            width={width}\n            height={height}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n            debug={debug}\n        />\n    )\n}\n\nMesh.propTypes = {\n    points: PropTypes.arrayOf(PropTypes.object).isRequired,\n    width: PropTypes.number.isRequired,\n    height: PropTypes.number.isRequired,\n    margin: PropTypes.object.isRequired,\n    setCurrent: PropTypes.func.isRequired,\n    onMouseEnter: PropTypes.func,\n    onMouseMove: PropTypes.func,\n    onMouseLeave: PropTypes.func,\n    onClick: PropTypes.func,\n    tooltip: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,\n    debug: PropTypes.bool.isRequired,\n}\n\nexport default memo(Mesh)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { Fragment, useState } from 'react'\nimport {\n    bindDefs,\n    withContainer,\n    useDimensions,\n    useTheme,\n    SvgWrapper,\n    CartesianMarkers,\n} from '@nivo/core'\nimport { useInheritedColor } from '@nivo/colors'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { Crosshair } from '@nivo/tooltip'\nimport { useLine } from './hooks'\nimport { LinePropTypes, LineDefaultProps } from './props'\nimport Areas from './Areas'\nimport Lines from './Lines'\nimport Slices from './Slices'\nimport Points from './Points'\nimport Mesh from './Mesh'\n\nconst Line = props => {\n    const {\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        layers,\n        curve,\n        areaBaselineValue,\n\n        colors,\n\n        margin: partialMargin,\n        width,\n        height,\n\n        axisTop,\n        axisRight,\n        axisBottom,\n        axisLeft,\n        enableGridX,\n        enableGridY,\n        gridXValues,\n        gridYValues,\n\n        lineWidth,\n        enableArea,\n        areaOpacity,\n        areaBlendMode,\n\n        enablePoints,\n        pointSymbol,\n        pointSize,\n        pointColor,\n        pointBorderWidth,\n        pointBorderColor,\n        enablePointLabel,\n        pointLabel,\n        pointLabelYOffset,\n\n        defs,\n        fill,\n\n        markers,\n\n        legends,\n\n        isInteractive,\n\n        useMesh,\n        debugMesh,\n\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onClick,\n\n        tooltip,\n\n        enableSlices,\n        debugSlices,\n        sliceTooltip,\n\n        enableCrosshair,\n        crosshairType,\n\n        role,\n    } = props\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n        enableSlices,\n    })\n\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n\n    const [currentPoint, setCurrentPoint] = useState(null)\n    const [currentSlice, setCurrentSlice] = useState(null)\n\n    const layerById = {\n        grid: (\n            <Grid\n                key=\"grid\"\n                theme={theme}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? xScale : null}\n                yScale={enableGridY ? yScale : null}\n                xValues={gridXValues}\n                yValues={gridYValues}\n            />\n        ),\n        markers: (\n            <CartesianMarkers\n                key=\"markers\"\n                markers={markers}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={xScale}\n                yScale={yScale}\n                theme={theme}\n            />\n        ),\n        axes: (\n            <Axes\n                key=\"axes\"\n                xScale={xScale}\n                yScale={yScale}\n                width={innerWidth}\n                height={innerHeight}\n                theme={theme}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        ),\n        areas: null,\n        lines: (\n            <Lines key=\"lines\" lines={series} lineGenerator={lineGenerator} lineWidth={lineWidth} />\n        ),\n        slices: null,\n        points: null,\n        crosshair: null,\n        mesh: null,\n        legends: legends.map((legend, i) => (\n            <BoxLegendSvg\n                key={`legend.${i}`}\n                {...legend}\n                containerWidth={innerWidth}\n                containerHeight={innerHeight}\n                data={legend.data || legendData}\n                theme={theme}\n                toggleSerie={legend.toggleSerie ? toggleSerie : undefined}\n            />\n        )),\n    }\n\n    const boundDefs = bindDefs(defs, series, fill)\n\n    if (enableArea) {\n        layerById.areas = (\n            <Areas\n                key=\"areas\"\n                areaGenerator={areaGenerator}\n                areaOpacity={areaOpacity}\n                areaBlendMode={areaBlendMode}\n                lines={series}\n            />\n        )\n    }\n\n    if (isInteractive && enableSlices !== false) {\n        layerById.slices = (\n            <Slices\n                key=\"slices\"\n                slices={slices}\n                axis={enableSlices}\n                debug={debugSlices}\n                height={innerHeight}\n                tooltip={sliceTooltip}\n                current={currentSlice}\n                setCurrent={setCurrentSlice}\n            />\n        )\n    }\n\n    if (enablePoints) {\n        layerById.points = (\n            <Points\n                key=\"points\"\n                points={points}\n                symbol={pointSymbol}\n                size={pointSize}\n                color={getPointColor}\n                borderWidth={pointBorderWidth}\n                borderColor={getPointBorderColor}\n                enableLabel={enablePointLabel}\n                label={pointLabel}\n                labelYOffset={pointLabelYOffset}\n            />\n        )\n    }\n\n    if (isInteractive && enableCrosshair) {\n        if (currentPoint !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentPoint.x}\n                    y={currentPoint.y}\n                    type={crosshairType}\n                />\n            )\n        }\n        if (currentSlice !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentSlice.x}\n                    y={currentSlice.y}\n                    type={enableSlices}\n                />\n            )\n        }\n    }\n\n    if (isInteractive && useMesh && enableSlices === false) {\n        layerById.mesh = (\n            <Mesh\n                key=\"mesh\"\n                points={points}\n                width={innerWidth}\n                height={innerHeight}\n                margin={margin}\n                current={currentPoint}\n                setCurrent={setCurrentPoint}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onClick={onClick}\n                tooltip={tooltip}\n                debug={debugMesh}\n            />\n        )\n    }\n\n    return (\n        <SvgWrapper\n            defs={boundDefs}\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return (\n                        <Fragment key={i}>\n                            {layer({\n                                ...props,\n                                innerWidth,\n                                innerHeight,\n                                series,\n                                slices,\n                                points,\n                                xScale,\n                                yScale,\n                                lineGenerator,\n                                areaGenerator,\n                                currentPoint,\n                                setCurrentPoint,\n                                currentSlice,\n                                setCurrentSlice,\n                            })}\n                        </Fragment>\n                    )\n                }\n\n                return layerById[layer]\n            })}\n        </SvgWrapper>\n    )\n}\n\nLine.propTypes = LinePropTypes\nLine.defaultProps = LineDefaultProps\n\nexport default withContainer(Line)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { createElement, useRef, useEffect, useState, useCallback, forwardRef } from 'react'\nimport {\n    withContainer,\n    useDimensions,\n    useTheme,\n    getRelativeCursor,\n    isCursorInRect,\n} from '@nivo/core'\nimport { renderAxesToCanvas, renderGridLinesToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport { useVoronoiMesh, renderVoronoiToCanvas, renderVoronoiCellToCanvas } from '@nivo/voronoi'\nimport { LineCanvasPropTypes, LineCanvasDefaultProps } from './props'\nimport { useLine } from './hooks'\n\nconst LineCanvas = ({\n    width,\n    height,\n    margin: partialMargin,\n    pixelRatio,\n\n    data,\n    xScale: xScaleSpec,\n    xFormat,\n    yScale: yScaleSpec,\n    yFormat,\n    curve,\n\n    layers,\n\n    colors,\n    lineWidth,\n\n    enableArea,\n    areaBaselineValue,\n    areaOpacity,\n\n    enablePoints,\n    pointSize,\n    pointColor,\n    pointBorderWidth,\n    pointBorderColor,\n\n    enableGridX,\n    gridXValues,\n    enableGridY,\n    gridYValues,\n    axisTop,\n    axisRight,\n    axisBottom,\n    axisLeft,\n\n    legends,\n\n    isInteractive,\n    debugMesh,\n    //onMouseEnter,\n    //onMouseMove,\n    onMouseLeave,\n    onClick,\n    tooltip,\n\n    canvasRef,\n}) => {\n    const canvasEl = useRef(null)\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n    const theme = useTheme()\n    const [currentPoint, setCurrentPoint] = useState(null)\n\n    const { lineGenerator, areaGenerator, series, xScale, yScale, points } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n    })\n\n    const { delaunay, voronoi } = useVoronoiMesh({\n        points,\n        width: innerWidth,\n        height: innerHeight,\n        debug: debugMesh,\n    })\n\n    useEffect(() => {\n        if (canvasRef) {\n            canvasRef.current = canvasEl.current\n        }\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        const ctx = canvasEl.current.getContext('2d')\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (typeof layer === 'function') {\n                layer({\n                    ctx,\n                    innerWidth,\n                    innerHeight,\n                    series,\n                    points,\n                    xScale,\n                    yScale,\n                    lineWidth,\n                    lineGenerator,\n                    areaGenerator,\n                    currentPoint,\n                    setCurrentPoint,\n                })\n            }\n\n            if (layer === 'grid' && theme.grid.line.strokeWidth > 0) {\n                ctx.lineWidth = theme.grid.line.strokeWidth\n                ctx.strokeStyle = theme.grid.line.stroke\n\n                enableGridX &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: xScale,\n                        axis: 'x',\n                        values: gridXValues,\n                    })\n\n                enableGridY &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: yScale,\n                        axis: 'y',\n                        values: gridYValues,\n                    })\n            }\n\n            if (layer === 'axes') {\n                renderAxesToCanvas(ctx, {\n                    xScale,\n                    yScale,\n                    width: innerWidth,\n                    height: innerHeight,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft,\n                    theme,\n                })\n            }\n\n            if (layer === 'areas' && enableArea === true) {\n                ctx.save()\n                ctx.globalAlpha = areaOpacity\n\n                areaGenerator.context(ctx)\n                series.forEach(serie => {\n                    ctx.fillStyle = serie.color\n                    ctx.beginPath()\n                    areaGenerator(serie.data.map(d => d.position))\n                    ctx.fill()\n                })\n\n                ctx.restore()\n            }\n\n            if (layer === 'lines') {\n                lineGenerator.context(ctx)\n                series.forEach(serie => {\n                    ctx.strokeStyle = serie.color\n                    ctx.lineWidth = lineWidth\n                    ctx.beginPath()\n                    lineGenerator(serie.data.map(d => d.position))\n                    ctx.stroke()\n                })\n            }\n\n            if (layer === 'points' && enablePoints === true && pointSize > 0) {\n                points.forEach(point => {\n                    ctx.fillStyle = point.color\n                    ctx.beginPath()\n                    ctx.arc(point.x, point.y, pointSize / 2, 0, 2 * Math.PI)\n                    ctx.fill()\n\n                    if (pointBorderWidth > 0) {\n                        ctx.strokeStyle = point.borderColor\n                        ctx.lineWidth = pointBorderWidth\n                        ctx.stroke()\n                    }\n                })\n            }\n\n            if (layer === 'mesh' && debugMesh === true) {\n                renderVoronoiToCanvas(ctx, voronoi)\n                if (currentPoint) {\n                    renderVoronoiCellToCanvas(ctx, voronoi, currentPoint.index)\n                }\n            }\n\n            if (layer === 'legends') {\n                const legendData = series\n                    .map(serie => ({\n                        id: serie.id,\n                        label: serie.id,\n                        color: serie.color,\n                    }))\n                    .reverse()\n\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legend.data || legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            }\n        })\n    }, [\n        canvasEl,\n        outerWidth,\n        outerHeight,\n        layers,\n        theme,\n        lineGenerator,\n        series,\n        xScale,\n        yScale,\n        enableGridX,\n        gridXValues,\n        enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom,\n        axisLeft,\n        legends,\n        points,\n        enablePoints,\n        pointSize,\n        currentPoint,\n    ])\n\n    const getPointFromMouseEvent = useCallback(\n        event => {\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            if (!isCursorInRect(margin.left, margin.top, innerWidth, innerHeight, x, y)) return null\n\n            const pointIndex = delaunay.find(x - margin.left, y - margin.top)\n            return points[pointIndex]\n        },\n        [canvasEl, margin, innerWidth, innerHeight, delaunay]\n    )\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        event => {\n            const point = getPointFromMouseEvent(event)\n            setCurrentPoint(point)\n\n            if (point) {\n                showTooltipFromEvent(createElement(tooltip, { point }), event)\n            } else {\n                hideTooltip()\n            }\n        },\n        [getPointFromMouseEvent, setCurrentPoint, showTooltipFromEvent, hideTooltip, tooltip]\n    )\n\n    const handleMouseLeave = useCallback(\n        event => {\n            hideTooltip()\n            setCurrentPoint(null)\n            currentPoint && onMouseLeave && onMouseLeave(currentPoint, event)\n        },\n        [hideTooltip, setCurrentPoint, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        event => {\n            if (onClick) {\n                const point = getPointFromMouseEvent(event)\n                point && onClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onClick]\n    )\n\n    return (\n        <canvas\n            ref={canvasEl}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n        />\n    )\n}\n\nLineCanvas.propTypes = LineCanvasPropTypes\nLineCanvas.defaultProps = LineCanvasDefaultProps\n\nconst LineCanvasWithContainer = withContainer(LineCanvas)\n\nexport default forwardRef((props, ref) => <LineCanvasWithContainer {...props} canvasRef={ref} />)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { forwardRef } from 'react'\nimport { ResponsiveWrapper } from '@nivo/core'\nimport LineCanvas from './LineCanvas'\n\nconst ResponsiveLineCanvas = (props, ref) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <LineCanvas width={width} height={height} {...props} ref={ref} />}\n    </ResponsiveWrapper>\n)\n\nexport default forwardRef(ResponsiveLineCanvas)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { ResponsiveWrapper } from '@nivo/core'\nimport Line from './Line'\n\nconst ResponsiveLine = props => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Line width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n\nexport default ResponsiveLine\n"],"names":["LinePointTooltip","point","_jsx","BasicTooltip","id","_jsxs","data","xFormatted","yFormatted","enableChip","color","serieColor","propTypes","PropTypes","object","isRequired","memo","SliceTooltip","slice","axis","theme","useTheme","otherAxis","TableTooltip","rows","points","map","Chip","style","tooltip","chip","serieId","tableCellValue","oneOf","commonPropTypes","arrayOf","shape","oneOfType","string","number","x","instanceOf","Date","y","xScale","xFormat","func","yScale","yFormat","layers","curve","lineCurvePropType","axisTop","axisPropType","axisRight","axisBottom","axisLeft","enableGridX","bool","enableGridY","gridXValues","gridYValues","enablePoints","pointSymbol","pointSize","pointColor","any","pointBorderWidth","pointBorderColor","enablePointLabel","pointLabel","markers","value","colors","ordinalColorsPropType","enableArea","areaOpacity","areaBlendMode","blendModePropType","areaBaselineValue","lineWidth","legends","LegendPropShape","isInteractive","debugMesh","enableSlices","debugSlices","sliceTooltip","enableCrosshair","crosshairType","LinePropTypes","role","useMesh","motionPropTypes","defsPropTypes","LineCanvasPropTypes","pixelRatio","commonDefaultProps","type","min","max","from","scheme","PointTooltip","LineDefaultProps","animate","motionConfig","defs","fill","LineCanvasDefaultProps","window","devicePixelRatio","useLineGenerator","useMemo","line","defined","d","curveFromProp","useAreaGenerator","area","y1","y0","useSlices","width","height","Map","forEach","has","get","push","set","Array","entries","sort","a","b","i","slices","x0","slicePoints","prevSlice","nextSlice","reverse","sliceHeight","useLine","xScaleSpec","yScaleSpec","enableSlicesTooltip","formatX","useValueFormatter","formatY","getColor","useOrdinalColorScale","getPointColor","useInheritedColor","getPointBorderColor","useState","hiddenIds","setHiddenIds","computeXYScalesForSeries","filter","item","indexOf","rawSeries","series","dataWithColor","label","datum","find","serie","Boolean","legendData","hidden","toggleSerie","useCallback","state","reduce","acc","position","index","length","borderColor","usePoints","lineGenerator","areaGenerator","AreaPath","path","useMotionConfig","springConfig","config","animatedPath","useAnimatedPath","animatedProps","useSpring","immediate","animated","fillOpacity","strokeWidth","mixBlendMode","Areas","computedLines","lines","LinesItem","thickness","stroke","Lines","SlicesItem","debug","isCurrent","setCurrent","useTooltip","showTooltipFromEvent","hideTooltip","handleMouseEnter","event","createElement","handleMouseMove","handleMouseLeave","strokeOpacity","onMouseEnter","onMouseMove","onMouseLeave","Slices","current","Points","symbol","size","borderWidth","enableLabel","labelYOffset","getLabel","getLabelGenerator","mappedPoints","DotsItem","Mesh","margin","onClick","showTooltipAt","left","top","handleClick","BaseMesh","nodes","Line","props","partialMargin","pointLabelYOffset","useDimensions","innerWidth","innerHeight","outerWidth","outerHeight","currentPoint","setCurrentPoint","currentSlice","setCurrentSlice","layerById","grid","Grid","xValues","yValues","CartesianMarkers","axes","Axes","right","bottom","areas","crosshair","mesh","legend","BoxLegendSvg","containerWidth","containerHeight","undefined","boundDefs","bindDefs","Crosshair","SvgWrapper","layer","Fragment","defaultProps","withContainer","LineCanvas","canvasRef","canvasEl","useRef","useVoronoiMesh","delaunay","voronoi","useEffect","ctx","getContext","scale","fillStyle","background","fillRect","translate","strokeStyle","renderGridLinesToCanvas","values","renderAxesToCanvas","save","globalAlpha","context","beginPath","restore","arc","Math","PI","renderVoronoiToCanvas","renderVoronoiCellToCanvas","renderLegendToCanvas","getPointFromMouseEvent","getRelativeCursor","isCursorInRect","pointIndex","handleMouseHover","ref","cursor","LineCanvasWithContainer","forwardRef","ResponsiveWrapper"],"mappings":"mnCAYA,IAAMA,EAAmB,gBAAGC,IAAAA,aAEpBC,MAACC,gBACGC,GACIC,+BACOH,yBAASD,EAAMK,KAAKC,oBAAyB,IAChDL,yBAASD,EAAMK,KAAKE,gBAG5BC,YAAY,EACZC,MAAOT,EAAMU,cAKzBX,EAAiBY,UAAY,CACzBX,MAAOY,UAAUC,OAAOC,kBAGbC,OAAKhB,GClBdiB,EAAe,gBAAGC,IAAAA,MAAOC,IAAAA,KACrBC,EAAQC,aACRC,EAAqB,MAATH,EAAe,IAAM,WAGnCjB,MAACqB,gBACGC,KAAMN,EAAMO,OAAOC,KAAI,SAAAzB,SAAS,CAC5BC,MAACyB,QAAgBjB,MAAOT,EAAMU,WAAYiB,MAAOR,EAAMS,QAAQC,MAArD,QACV7B,EAAM8B,QACN7B,cAAkB0B,MAAOR,EAAMS,QAAQG,wBAClC/B,EAAMK,KAAQgB,gBADT,gBAQ1BL,EAAaL,UAAY,CACrBM,MAAOL,UAAUC,OAAOC,WACxBI,KAAMN,UAAUoB,MAAM,CAAC,IAAK,MAAMlB,kBAGvBC,OAAKC,GCnBdiB,EAAkB,CACpB5B,KAAMO,UAAUsB,QACZtB,UAAUuB,MAAM,CACZhC,GAAIS,UAAUwB,UAAU,CAACxB,UAAUyB,OAAQzB,UAAU0B,SAASxB,WAC9DT,KAAMO,UAAUsB,QACZtB,UAAUuB,MAAM,CACZI,EAAG3B,UAAUwB,UAAU,CACnBxB,UAAU0B,OACV1B,UAAUyB,OACVzB,UAAU4B,WAAWC,QAEzBC,EAAG9B,UAAUwB,UAAU,CACnBxB,UAAU0B,OACV1B,UAAUyB,OACVzB,UAAU4B,WAAWC,WAG/B3B,cAERA,WAEF6B,OAAQ/B,UAAUC,OAAOC,WACzB8B,QAAShC,UAAUwB,UAAU,CAACxB,UAAUiC,KAAMjC,UAAUyB,SACxDS,OAAQlC,UAAUC,OAAOC,WACzBiC,QAASnC,UAAUwB,UAAU,CAACxB,UAAUiC,KAAMjC,UAAUyB,SAExDW,OAAQpC,UAAUsB,QACdtB,UAAUwB,UAAU,CAChBxB,UAAUoB,MAAM,CACZ,OACA,UACA,OACA,QACA,YACA,QACA,SACA,SACA,OACA,YAEJpB,UAAUiC,QAEhB/B,WAEFmC,MAAOC,oBAAkBpC,WAEzBqC,QAASC,eACTC,UAAWD,eACXE,WAAYF,eACZG,SAAUH,eAEVI,YAAa5C,UAAU6C,KAAK3C,WAC5B4C,YAAa9C,UAAU6C,KAAK3C,WAC5B6C,YAAa/C,UAAUwB,UAAU,CAC7BxB,UAAU0B,OACV1B,UAAUsB,QACNtB,UAAUwB,UAAU,CAACxB,UAAU0B,OAAQ1B,UAAUyB,OAAQzB,UAAU4B,WAAWC,WAGtFmB,YAAahD,UAAUwB,UAAU,CAC7BxB,UAAU0B,OACV1B,UAAUsB,QACNtB,UAAUwB,UAAU,CAACxB,UAAU0B,OAAQ1B,UAAUyB,OAAQzB,UAAU4B,WAAWC,WAItFoB,aAAcjD,UAAU6C,KAAK3C,WAC7BgD,YAAalD,UAAUiC,KACvBkB,UAAWnD,UAAU0B,OAAOxB,WAC5BkD,WAAYpD,UAAUqD,IAAInD,WAC1BoD,iBAAkBtD,UAAU0B,OAAOxB,WACnCqD,iBAAkBvD,UAAUqD,IAAInD,WAChCsD,iBAAkBxD,UAAU6C,KAAK3C,WACjCuD,WAAYzD,UAAUwB,UAAU,CAACxB,UAAUyB,OAAQzB,UAAUiC,OAAO/B,WAEpEwD,QAAS1D,UAAUsB,QACftB,UAAUuB,MAAM,CACZjB,KAAMN,UAAUoB,MAAM,CAAC,IAAK,MAAMlB,WAClCyD,MAAO3D,UAAUwB,UAAU,CACvBxB,UAAU0B,OACV1B,UAAUyB,OACVzB,UAAU4B,WAAWC,QACtB3B,WACHa,MAAOf,UAAUC,UAIzB2D,OAAQC,wBAAsB3D,WAE9B4D,WAAY9D,UAAU6C,KAAK3C,WAC3B6D,YAAa/D,UAAU0B,OAAOxB,WAC9B8D,cAAeC,oBAAkB/D,WACjCgE,kBAAmBlE,UAAUwB,UAAU,CACnCxB,UAAU0B,OACV1B,UAAUyB,OACVzB,UAAU4B,WAAWC,QACtB3B,WACHiE,UAAWnE,UAAU0B,OAAOxB,WAE5BkE,QAASpE,UAAUsB,QAAQtB,UAAUuB,MAAM8C,oBAAkBnE,WAE7DoE,cAAetE,UAAU6C,KAAK3C,WAC9BqE,UAAWvE,UAAU6C,KAAK3C,WAE1Bc,QAAShB,UAAUwB,UAAU,CAACxB,UAAUiC,KAAMjC,UAAUC,SAASC,WAEjEsE,aAAcxE,UAAUoB,MAAM,CAAC,IAAK,KAAK,IAAQlB,WACjDuE,YAAazE,UAAU6C,KAAK3C,WAC5BwE,aAAc1E,UAAUwB,UAAU,CAACxB,UAAUiC,KAAMjC,UAAUC,SAASC,WAEtEyE,gBAAiB3E,UAAU6C,KAAK3C,WAChC0E,cAAe5E,UAAUyB,OAAOvB,YAGvB2E,OACNxD,GACHmC,iBAAkBxD,UAAU6C,KAAK3C,WACjC4E,KAAM9E,UAAUyB,OAAOvB,WACvB6E,QAAS/E,UAAU6C,KAAK3C,YACrB8E,kBACAC,iBAGMC,KACTC,WAAYnF,UAAU0B,OAAOxB,YAC1BmB,GAGD+D,EAAqB,CACvB/C,MAAO,SAEPN,OAAQ,CACJsD,KAAM,SAEVnD,OAAQ,CACJmD,KAAM,SACNC,IAAK,EACLC,IAAK,QAGTnD,OAAQ,CACJ,OACA,UACA,OACA,QACA,YACA,QACA,SACA,SACA,OACA,WAEJM,WAAY,GACZC,SAAU,GACVC,aAAa,EACbE,aAAa,EAEbG,cAAc,EACdE,UAAW,EACXC,WAAY,CAAEoC,KAAM,SACpBlC,iBAAkB,EAClBC,iBAAkB,CAAEhD,MAAO,cAC3BiD,kBAAkB,EAClBC,WAAY,aAEZG,OAAQ,CAAE6B,OAAQ,QAClB3B,YAAY,EACZI,kBAAmB,EACnBH,YAAa,GACbC,cAAe,SACfG,UAAW,EAEXC,QAAS,GAETE,eAAe,EACftD,QAAS0E,EACTlB,cAAc,EACdC,aAAa,EACbC,aAActE,EACdmE,WAAW,EACXI,iBAAiB,EACjBC,cAAe,eAGNe,OACNP,GACH5B,kBAAkB,EAClBuB,SAAS,EACTa,SAAS,EACTC,aAAc,SACdC,KAAM,GACNC,KAAM,GACNjB,KAAM,QAGGkB,OACNZ,GACHD,WAA8B,oBAAXc,QAAyBA,OAAOC,kBAAwB,ICtMlEC,EAAmB,gBAAG9D,IAAAA,aACxB+D,WACH,kBACIC,SACKC,SAAQ,SAAAC,UAAa,OAARA,EAAE5E,GAAsB,OAAR4E,EAAEzE,KAC/BH,GAAE,SAAA4E,UAAKA,EAAE5E,KACTG,GAAE,SAAAyE,UAAKA,EAAEzE,KACTO,MAAMmE,gBAAcnE,MAC7B,CAACA,KAIIoE,EAAmB,gBAAGpE,IAAAA,MAAOH,IAAAA,OAAQgC,IAAAA,yBACvCkC,WAAQ,kBACJM,SACFJ,SAAQ,SAAAC,UAAa,OAARA,EAAE5E,GAAsB,OAAR4E,EAAEzE,KAC/BH,GAAE,SAAA4E,UAAKA,EAAE5E,KACTgF,IAAG,SAAAJ,UAAKA,EAAEzE,KACVO,MAAMmE,gBAAcnE,IACpBuE,GAAG1E,EAAOgC,MAChB,CAAC7B,EAAOH,EAAQgC,KAkCV2C,EAAY,gBAAGrC,IAAAA,aAAc5D,IAAAA,OAAQkG,IAAAA,MAAOC,IAAAA,cAC9CX,WAAQ,eACU,IAAjB5B,EAAwB,MAAO,MAEd,MAAjBA,EAAsB,KAChB3D,EAAM,IAAImG,WAChBpG,EAAOqG,SAAQ,SAAA7H,GACU,OAAjBA,EAAMK,KAAKkC,GAA+B,OAAjBvC,EAAMK,KAAKqC,IACnCjB,EAAIqG,IAAI9H,EAAMuC,GACdd,EAAIsG,IAAI/H,EAAMuC,GAAGyF,KAAKhI,GADJyB,EAAIwG,IAAIjI,EAAMuC,EAAG,CAACvC,QAGtCkI,MAAM9B,KAAK3E,EAAI0G,WACjBC,MAAK,SAACC,EAAGC,UAAMD,EAAE,GAAKC,EAAE,MACxB7G,KAAI,WAAmB8G,EAAGC,OAInBC,EAJDlG,OAAGmG,OACAC,EAAYH,EAAOD,EAAI,GACvBK,EAAYJ,EAAOD,EAAI,SAUtB,CACHpI,GAAIoC,EACJkG,GARCA,EADAE,EACKpG,GAAKA,EAAIoG,EAAU,IAAM,EADdpG,EAUjBA,EAAAA,EACAiF,GAAI,EACJ9E,EAAG,EACHgF,MATCkB,EACarG,EAAIkG,GAAMG,EAAU,GAAKrG,GAAK,EADnBmF,EAAQe,EAUjCd,OAAAA,EACAnG,OAAQkH,EAAYG,cAG7B,GAAqB,MAAjBzD,EAAsB,KACvB3D,EAAM,IAAImG,WAChBpG,EAAOqG,SAAQ,SAAA7H,GACU,OAAjBA,EAAMK,KAAKkC,GAA+B,OAAjBvC,EAAMK,KAAKqC,IACnCjB,EAAIqG,IAAI9H,EAAM0C,GACdjB,EAAIsG,IAAI/H,EAAM0C,GAAGsF,KAAKhI,GADJyB,EAAIwG,IAAIjI,EAAM0C,EAAG,CAAC1C,QAGtCkI,MAAM9B,KAAK3E,EAAI0G,WACjBC,MAAK,SAACC,EAAGC,UAAMD,EAAE,GAAKC,EAAE,MACxB7G,KAAI,WAAmB8G,EAAGC,OAInBhB,EAIAsB,EARDpG,OAAGgG,OACAC,EAAYH,EAAOD,EAAI,GACvBK,EAAYJ,EAAOD,EAAI,UAIxBf,EADAmB,EACKjG,GAAKA,EAAIiG,EAAU,IAAM,EADdjG,EAKhBoG,EADAF,EACclG,EAAI8E,GAAMoB,EAAU,GAAKlG,GAAK,EADnBiF,EAASH,EAGhC,CACHrH,GAAIuC,EACJ+F,GAAI,EACJlG,EAAG,EACHiF,GAAAA,EACA9E,EAAAA,EACAgF,MAAAA,EACAC,OAAQmB,EACRtH,OAAQkH,EAAYG,iBAIrC,CAACzD,EAAc5D,KAGTuH,EAAU,gBACnB1I,IAAAA,SACAsC,OAAQqG,aAAazC,EAAiB5D,SACtCC,IAAAA,YACAE,OAAQmG,aAAa1C,EAAiBzD,SACtCC,IAAAA,QACA2E,IAAAA,MACAC,IAAAA,WACAnD,OAAAA,aAAS+B,EAAiB/B,aAC1BvB,MAAAA,aAAQsD,EAAiBtD,YACzB6B,kBAAAA,aAAoByB,EAAiBzB,wBACrCd,WAAAA,aAAauC,EAAiBvC,iBAC9BG,iBAAAA,aAAmBoC,EAAiBpC,uBACpCiB,aAAAA,aAAemB,EAAiB2C,sBAE1BC,EAAUC,oBAAkBxG,GAC5ByG,EAAUD,oBAAkBrG,GAC5BuG,EAAWC,uBAAqB/E,EAAQ,MACxCrD,EAAQC,aACRoI,EAAgBC,oBAAkBzF,EAAY7C,GAC9CuI,EAAsBD,oBAAkBtF,EAAkBhD,KAC9BwI,WAAS,IAApCC,OAAWC,SAMd7C,WACA,kBACI8C,2BACIzJ,EAAK0J,QAAO,SAAAC,UAAwC,IAAhCJ,EAAUK,QAAQD,EAAK7J,OAC3C6I,EACAC,EACAvB,EACAC,KAER,CAACtH,EAAMuJ,EAAWZ,EAAYC,EAAYvB,EAAOC,IAZjDhF,IAAAA,OACAG,IAAAA,OACQoH,IAARC,SAa2BnD,WAAQ,eAC7BoD,EAAgB/J,EAAKoB,KAAI,SAAAwF,SAAS,CACpC9G,GAAI8G,EAAK9G,GACTkK,MAAOpD,EAAK9G,GACZM,MAAO6I,EAASrC,OAEdkD,EAASC,EACV3I,KAAI,SAAA6I,eACEJ,EAAUK,MAAK,SAAAC,UAASA,EAAMrK,KAAOmK,EAAMnK,OAC9CM,MAAO6J,EAAM7J,WAEhBsJ,QAAO,SAAAC,UAAQS,QAAQT,EAAK7J,aAK1B,CAAEuK,WAJUN,EACd3I,KAAI,SAAAuI,eAAcA,GAAMW,QAASR,EAAOI,MAAK,SAAAC,UAASA,EAAMrK,KAAO6J,EAAK7J,WACxE0I,UAEgBsB,OAAAA,KACtB,CAAC9J,EAAM6J,EAAWZ,IAjBboB,IAAAA,WAAYP,IAAAA,OAmBdS,EAAcC,eAAY,SAAA1K,GAC5B0J,GAAa,SAAAiB,UACTA,EAAMb,QAAQ9J,IAAO,EAAI2K,EAAMf,QAAO,SAAAC,UAAQA,IAAS7J,eAAU2K,GAAO3K,SAE7E,IAEGqB,EAvKQ,gBAAG2I,IAAAA,OAAQX,IAAAA,cAAeE,IAAAA,oBAAqBP,IAAAA,QAASE,IAAAA,eAC/DrC,WAAQ,kBACJmD,EAAOY,QAAO,SAACC,EAAKR,mBAEhBQ,EACAR,EAAMnK,KACJ0J,QAAO,SAAAO,UAA8B,OAArBA,EAAMW,SAAS1I,GAAmC,OAArB+H,EAAMW,SAASvI,KAC5DjB,KAAI,SAAC6I,EAAO/B,OACHvI,EAAQ,CACVG,GAAOqK,EAAMrK,OAAMoI,EACnB2C,MAAOF,EAAIG,OAAS5C,EACpBzG,QAAS0I,EAAMrK,GACfO,WAAY8J,EAAM/J,MAClB8B,EAAG+H,EAAMW,SAAS1I,EAClBG,EAAG4H,EAAMW,SAASvI,UAEtB1C,EAAMS,MAAQ+I,EAAcgB,GAC5BxK,EAAMoL,YAAc1B,EAAoB1J,GACxCA,EAAMK,UACCiK,EAAMjK,MACTC,WAAY6I,EAAQmB,EAAMjK,KAAKkC,GAC/BhC,WAAY8I,EAAQiB,EAAMjK,KAAKqC,KAG5B1C,QAGpB,MACJ,CAACmK,EAAQX,EAAeE,EAAqBP,EAASE,IA2I1CgC,CAAU,CACrBlB,OAAAA,EACAX,cAAAA,EACAE,oBAAAA,EACAP,QAAAA,EACAE,QAAAA,IAGEb,EAASf,EAAU,CACrBrC,aAAAA,EACA5D,OAAAA,EACAkG,MAAAA,EACAC,OAAAA,UAUG,CACH+C,WAAAA,EACAE,YAAAA,EACAU,cAVkBvE,EAAiB,CAAE9D,MAAAA,IAWrCsI,cAVkBlE,EAAiB,CACnCpE,MAAAA,EACAH,OAAAA,EACAgC,kBAAAA,IAQAwE,SAAAA,EACAa,OAAAA,EACAxH,OAAAA,EACAG,OAAAA,EACA0F,OAAAA,EACAhH,OAAAA,IChOFgK,EAAW,gBAAG5G,IAAAA,cAAeD,IAAAA,YAAalE,IAAAA,MAAOkG,IAAAA,KAAM8E,IAAAA,OACfC,oBAAlClF,IAAAA,QAAiBmF,IAARC,OAEXC,EAAeC,kBAAgBL,GAC/BM,EAAgBC,YAAU,CAC5BvL,MAAAA,EACAmL,OAAQD,EACRM,WAAYzF,WAIZvG,MAACiM,WAAST,MACNtE,EAAG0E,EACHlF,KAAMA,GAAcoF,EAActL,MAClC0L,YAAaxH,EACbyH,YAAa,EACbzK,MAAO,CACH0K,aAAczH,MAM9B4G,EAAS7K,UAAY,CACjBiE,cAAeC,oBAAkB/D,WACjC6D,YAAa/D,UAAU0B,OAAOxB,WAC9BL,MAAOG,UAAUyB,OACjBsE,KAAM/F,UAAUyB,OAChBoJ,KAAM7K,UAAUyB,OAAOvB,YAG3B,IAAMwL,EAAQ,gBAAGf,IAAAA,cAAe5G,IAAAA,YAAaC,IAAAA,cACnC2H,IADkDC,MAC5BvL,MAAM,GAAG4H,iBAGjC5I,oBACKsM,EAAc9K,KAAI,SAAAwF,UACfhH,MAACuL,KAEGC,KAAMF,EAActE,EAAK5G,KAAKoB,KAAI,SAAA0F,UAAKA,EAAE8D,iBACnCtG,YAAAA,EAAaC,cAAAA,GAAkBqC,IAFhCA,EAAK9G,UAS9BmM,EAAM3L,UAAY,CACd4K,cAAe3K,UAAUiC,KAAK/B,WAC9B6D,YAAa/D,UAAU0B,OAAOxB,WAC9B8D,cAAeC,oBAAkB/D,WACjC0L,MAAO5L,UAAUsB,QAAQtB,UAAUC,QAAQC,kBAGhCC,OAAKuL,GCtDdG,EAAY,gBAAGnB,IAAAA,cAAe9J,IAAAA,OAAQf,IAAAA,MAAOiM,IAAAA,UACzCjB,EAAOzE,WAAQ,kBAAMsE,EAAc9J,KAAS,CAAC8J,EAAe9J,IAC5DqK,EAAeC,kBAAgBL,UAE9BxL,MAACiM,WAAST,MAAKtE,EAAG0E,EAAclF,KAAK,OAAOyF,YAAaM,EAAWC,OAAQlM,KAGvFgM,EAAU9L,UAAY,CAClBa,OAAQZ,UAAUsB,QACdtB,UAAUuB,MAAM,CACZI,EAAG3B,UAAUwB,UAAU,CAACxB,UAAUyB,OAAQzB,UAAU0B,SACpDI,EAAG9B,UAAUwB,UAAU,CAACxB,UAAUyB,OAAQzB,UAAU0B,YAG5DgJ,cAAe1K,UAAUiC,KAAK/B,WAC9BL,MAAOG,UAAUyB,OAAOvB,WACxB4L,UAAW9L,UAAU0B,OAAOxB,kBAGjBC,OAAK0L,GCpBdG,EAAQ,gBAAGJ,IAAAA,MAAOlB,IAAAA,cAAevG,IAAAA,iBAC5ByH,EACFvL,MAAM,GACN4H,UACApH,KAAI,gBAAGtB,IAAAA,GAAIE,IAAAA,KAAMI,IAAAA,aACdR,MAACwM,GAEGtM,GAAIA,EACJqB,OAAQnB,EAAKoB,KAAI,SAAA0F,UAAKA,EAAE8D,YACxBK,cAAeA,EACf7K,MAAOA,EACPiM,UAAW3H,GALN5E,OAUrByM,EAAMjM,UAAY,CACd6L,MAAO5L,UAAUsB,QACbtB,UAAUuB,MAAM,CACZhC,GAAIS,UAAUwB,UAAU,CAACxB,UAAUyB,OAAQzB,UAAU0B,SAASxB,WAC9DL,MAAOG,UAAUyB,OAAOvB,WACxBT,KAAMO,UAAUsB,QACZtB,UAAUuB,MAAM,CACZ9B,KAAMO,UAAUuB,MAAM,CAClBI,EAAG3B,UAAUwB,UAAU,CACnBxB,UAAUyB,OACVzB,UAAU0B,OACV1B,UAAU4B,WAAWC,QAEzBC,EAAG9B,UAAUwB,UAAU,CACnBxB,UAAUyB,OACVzB,UAAU0B,OACV1B,UAAU4B,WAAWC,UAE1B3B,WACHmK,SAAUrK,UAAUuB,MAAM,CACtBI,EAAG3B,UAAU0B,OACbI,EAAG9B,UAAU0B,SACdxB,cAETA,cAERA,WACFiE,UAAWnE,UAAU0B,OAAOxB,WAC5BwK,cAAe1K,UAAUiC,KAAK/B,kBAGnBC,OAAK6L,GC/CdC,EAAa,gBAAG5L,IAAAA,MAAOC,IAAAA,KAAM4L,IAAAA,MAAOlL,IAAAA,QAASmL,IAAAA,UAAWC,IAAAA,aACZC,eAAtCC,IAAAA,qBAAsBC,IAAAA,YAExBC,EAAmBvC,eACrB,SAAAwC,GACIH,EAAqBI,gBAAc1L,EAAS,CAAEX,MAAAA,EAAOC,KAAAA,IAASmM,EAAO,SACrEL,EAAW/L,KAEf,CAACiM,EAAsBtL,EAASX,IAG9BsM,EAAkB1C,eACpB,SAAAwC,GACIH,EAAqBI,gBAAc1L,EAAS,CAAEX,MAAAA,EAAOC,KAAAA,IAASmM,EAAO,WAEzE,CAACH,EAAsBtL,EAASX,IAG9BuM,EAAmB3C,eAAY,WACjCsC,IACAH,EAAW,QACZ,CAACG,WAGAlN,cACIsC,EAAGtB,EAAMwH,GACT/F,EAAGzB,EAAMuG,GACTE,MAAOzG,EAAMyG,MACbC,OAAQ1G,EAAM0G,OACdgF,OAAO,MACPP,YAAaU,EAAQ,EAAI,EACzBW,cAAe,IACf9G,KAAK,MACLwF,YAAaY,GAAaD,EAAQ,IAAO,EACzCY,aAAcN,EACdO,YAAaJ,EACbK,aAAcJ,KAK1BX,EAAWlM,UAAY,CACnBM,MAAOL,UAAUC,OAAOC,WACxBI,KAAMN,UAAUoB,MAAM,CAAC,IAAK,MAAMlB,WAClCgM,MAAOlM,UAAU6C,KAAK3C,WACtB6G,OAAQ/G,UAAU0B,OAAOxB,WACzBc,QAAShB,UAAUwB,UAAU,CAACxB,UAAUiC,KAAMjC,UAAUC,SACxDkM,UAAWnM,UAAU6C,KAAK3C,WAC1BkM,WAAYpM,UAAUiC,KAAK/B,kBAGhBC,OAAK8L,GCnDdgB,EAAS,gBAAGrF,IAAAA,OAAQtH,IAAAA,KAAM4L,IAAAA,MAAOnF,IAAAA,OAAQ/F,IAAAA,QAASkM,IAAAA,QAASd,IAAAA,kBACtDxE,EAAO/G,KAAI,SAAAR,UACdhB,MAAC4M,GAEG5L,MAAOA,EACPC,KAAMA,EACN4L,MAAOA,EACPnF,OAAQA,EACR/F,QAASA,EACToL,WAAYA,EACZD,UAAuB,OAAZe,GAAoBA,EAAQ3N,KAAOc,EAAMd,IAP/Cc,EAAMd,QAYvB0N,EAAOlN,UAAY,CACf6H,OAAQ5H,UAAUsB,QACdtB,UAAUuB,MAAM,CACZhC,GAAIS,UAAUwB,UAAU,CACpBxB,UAAU0B,OACV1B,UAAUyB,OACVzB,UAAU4B,WAAWC,QACtB3B,WACHyB,EAAG3B,UAAU0B,OAAOxB,WACpB4B,EAAG9B,UAAU0B,OAAOxB,WACpBU,OAAQZ,UAAUsB,QAAQtB,UAAUC,QAAQC,cAElDA,WACFI,KAAMN,UAAUoB,MAAM,CAAC,IAAK,MAAMlB,WAClCgM,MAAOlM,UAAU6C,KAAK3C,WACtB6G,OAAQ/G,UAAU0B,OAAOxB,WACzBc,QAAShB,UAAUwB,UAAU,CAACxB,UAAUiC,KAAMjC,UAAUC,SAASC,WACjEgN,QAASlN,UAAUC,OACnBmM,WAAYpM,UAAUiC,KAAK/B,kBAGhBC,OAAK8M,GCpCdE,EAAS,gBAAGvM,IAAAA,OAAQwM,IAAAA,OAAQC,IAAAA,KAAMC,IAAAA,YAAaC,IAAAA,YAAa9D,IAAAA,MAAO+D,IAAAA,aAC/DjN,EAAQC,aACRiN,EAAWC,oBAAkBjE,GAM7BkE,EAAe/M,EAChBP,MAAM,GACN4H,UACApH,KAAI,SAAAzB,SACmB,CAChBG,GAAIH,EAAMG,GACVoC,EAAGvC,EAAMuC,EACTG,EAAG1C,EAAM0C,EACT4H,MAAOtK,EAAMK,KACbsG,KAAM3G,EAAMS,MACZkM,OAAQ3M,EAAMoL,YACdf,MAAO8D,EAAcE,EAASrO,EAAMK,MAAQ,gBAOpDJ,oBACKsO,EAAa9M,KAAI,SAAAzB,UACdC,MAACuO,YAEGjM,EAAGvC,EAAMuC,EACTG,EAAG1C,EAAM0C,EACT4H,MAAOtK,EAAMsK,MACb0D,OAAQA,EACRC,KAAMA,EACNxN,MAAOT,EAAM2G,KACbuH,YAAaA,EACb9C,YAAapL,EAAM2M,OACnBtC,MAAOrK,EAAMqK,MACb+D,aAAcA,EACdjN,MAAOA,GAXFnB,EAAMG,UAkB/B4N,EAAOpN,UAAY,CACfa,OAAQZ,UAAUsB,QAAQtB,UAAUC,QACpCmN,OAAQpN,UAAUiC,KAClBoL,KAAMrN,UAAU0B,OAAOxB,WACvBL,MAAOG,UAAUiC,KAAK/B,WACtBoN,YAAatN,UAAU0B,OAAOxB,WAC9BsK,YAAaxK,UAAUiC,KAAK/B,WAC5BqN,YAAavN,UAAU6C,KAAK3C,WAC5BuJ,MAAOzJ,UAAUwB,UAAU,CAACxB,UAAUyB,OAAQzB,UAAUiC,OAAO/B,WAC/DsN,aAAcxN,UAAU0B,cAGbvB,OAAKgN,GC1DdU,EAAO,gBACTjN,IAAAA,OACAkG,IAAAA,MACAC,IAAAA,OACA+G,IAAAA,OACA1B,IAAAA,WACAU,IAAAA,aACAC,IAAAA,YACAC,IAAAA,aACAe,IAAAA,QACA/M,IAAAA,QACAkL,IAAAA,QAEuCG,eAA/B2B,IAAAA,cAAezB,IAAAA,YAEjBC,EAAmBvC,eACrB,SAAC7K,EAAOqN,GACJuB,EACItB,gBAAc1L,EAAS,CAAE5B,MAAAA,IACzB,CAACA,EAAMuC,EAAImM,EAAOG,KAAM7O,EAAM0C,EAAIgM,EAAOI,KACzC,OAEJ9B,EAAWhN,GACX0N,GAAgBA,EAAa1N,EAAOqN,KAExC,CAACL,EAAY4B,EAAehN,EAAS8L,EAAcgB,IAGjDnB,EAAkB1C,eACpB,SAAC7K,EAAOqN,GACJuB,EACItB,gBAAc1L,EAAS,CAAE5B,MAAAA,IACzB,CAACA,EAAMuC,EAAImM,EAAOG,KAAM7O,EAAM0C,EAAIgM,EAAOI,KACzC,OAEJ9B,EAAWhN,GACX2N,GAAeA,EAAY3N,EAAOqN,KAEtC,CAACL,EAAY4B,EAAehN,EAAS+L,IAGnCH,EAAmB3C,eACrB,SAAC7K,EAAOqN,GACJF,IACAH,EAAW,MACXY,GAAgBA,EAAa5N,EAAOqN,KAExC,CAACF,EAAaH,EAAYY,IAGxBmB,EAAclE,eAChB,SAAC7K,EAAOqN,GACJsB,GAAWA,EAAQ3O,EAAOqN,KAE9B,CAACsB,WAID1O,MAAC+O,QACGC,MAAOzN,EACPkG,MAAOA,EACPC,OAAQA,EACR+F,aAAcN,EACdO,YAAaJ,EACbK,aAAcJ,EACdmB,QAASI,EACTjC,MAAOA,KAKnB2B,EAAK9N,UAAY,CACba,OAAQZ,UAAUsB,QAAQtB,UAAUC,QAAQC,WAC5C4G,MAAO9G,UAAU0B,OAAOxB,WACxB6G,OAAQ/G,UAAU0B,OAAOxB,WACzB4N,OAAQ9N,UAAUC,OAAOC,WACzBkM,WAAYpM,UAAUiC,KAAK/B,WAC3B4M,aAAc9M,UAAUiC,KACxB8K,YAAa/M,UAAUiC,KACvB+K,aAAchN,UAAUiC,KACxB8L,QAAS/N,UAAUiC,KACnBjB,QAAShB,UAAUwB,UAAU,CAACxB,UAAUiC,KAAMjC,UAAUC,SAASC,WACjEgM,MAAOlM,UAAU6C,KAAK3C,kBAGXC,OAAK0N,GCrEdS,EAAO,SAAAC,OAEL9O,EAkEA8O,EAlEA9O,KACQ2I,EAiERmG,EAjEAxM,OACAC,EAgEAuM,EAhEAvM,QACQqG,EA+DRkG,EA/DArM,OACAC,EA8DAoM,EA9DApM,QACAC,EA6DAmM,EA7DAnM,OACAC,EA4DAkM,EA5DAlM,MACA6B,EA2DAqK,EA3DArK,kBAEAN,EAyDA2K,EAzDA3K,OAEQ4K,EAuDRD,EAvDAT,OACAhH,EAsDAyH,EAtDAzH,MACAC,EAqDAwH,EArDAxH,OAEAxE,EAmDAgM,EAnDAhM,QACAE,EAkDA8L,EAlDA9L,UACAC,EAiDA6L,EAjDA7L,WACAC,EAgDA4L,EAhDA5L,SACAC,EA+CA2L,EA/CA3L,YACAE,EA8CAyL,EA9CAzL,YACAC,EA6CAwL,EA7CAxL,YACAC,EA4CAuL,EA5CAvL,YAEAmB,EA0CAoK,EA1CApK,UACAL,EAyCAyK,EAzCAzK,WACAC,EAwCAwK,EAxCAxK,YACAC,EAuCAuK,EAvCAvK,cAEAf,EAqCAsL,EArCAtL,aACAC,EAoCAqL,EApCArL,YACAC,EAmCAoL,EAnCApL,UACAC,EAkCAmL,EAlCAnL,WACAE,EAiCAiL,EAjCAjL,iBACAC,EAgCAgL,EAhCAhL,iBACAC,EA+BA+K,EA/BA/K,iBACAC,EA8BA8K,EA9BA9K,WACAgL,EA6BAF,EA7BAE,kBAEA3I,EA2BAyI,EA3BAzI,KACAC,EA0BAwI,EA1BAxI,KAEArC,EAwBA6K,EAxBA7K,QAEAU,EAsBAmK,EAtBAnK,QAEAE,EAoBAiK,EApBAjK,cAEAS,EAkBAwJ,EAlBAxJ,QACAR,GAiBAgK,EAjBAhK,UAEAuI,GAeAyB,EAfAzB,aACAC,GAcAwB,EAdAxB,YACAC,GAaAuB,EAbAvB,aACAe,GAYAQ,EAZAR,QAEA/M,GAUAuN,EAVAvN,QAEAwD,GAQA+J,EARA/J,aACAC,GAOA8J,EAPA9J,YACAC,GAMA6J,EANA7J,aAEAC,GAIA4J,EAJA5J,gBACAC,GAGA2J,EAHA3J,cAEAE,GACAyJ,EADAzJ,QAGiE4J,gBACjE5H,EACAC,EACAyH,GAHIV,MAAAA,OAAQa,MAAAA,WAAYC,MAAAA,YAAaC,MAAAA,WAAYC,MAAAA,eAgBjD3G,EAAQ,CACR1I,KAAAA,EACAsC,OAAQqG,EACRpG,QAAAA,EACAE,OAAQmG,EACRlG,QAAAA,EACA2E,MAAO6H,GACP5H,OAAQ6H,GACRhL,OAAAA,EACAvB,MAAAA,EACA6B,kBAAAA,EACAd,WAAAA,EACAG,iBAAAA,EACAiB,aAAAA,KAtBAsF,MAAAA,WACAE,MAAAA,YACAU,MAAAA,cACAC,MAAAA,cACApB,MAAAA,OACAxH,MAAAA,OACAG,MAAAA,OACA0F,MAAAA,OACAhH,MAAAA,OAiBEL,GAAQC,aACRoI,GAAgBC,oBAAkBzF,EAAY7C,IAC9CuI,GAAsBD,oBAAkBtF,EAAkBhD,OAExBwI,WAAS,MAA1CgG,SAAcC,YACmBjG,WAAS,MAA1CkG,SAAcC,SAEfC,GAAY,CACdC,KACI/P,MAACgQ,QAEG9O,MAAOA,GACPuG,MAAO6H,GACP5H,OAAQ6H,GACR7M,OAAQa,EAAcb,GAAS,KAC/BG,OAAQY,EAAcZ,GAAS,KAC/BoN,QAASvM,EACTwM,QAASvM,GAPL,QAUZU,QACIrE,MAACmQ,oBAEG9L,QAASA,EACToD,MAAO6H,GACP5H,OAAQ6H,GACR7M,OAAQA,GACRG,OAAQA,GACR3B,MAAOA,IANH,WASZkP,KACIpQ,MAACqQ,QAEG3N,OAAQA,GACRG,OAAQA,GACR4E,MAAO6H,GACP5H,OAAQ6H,GACRrO,MAAOA,GACP2N,IAAK3L,EACLoN,MAAOlN,EACPmN,OAAQlN,EACRuL,KAAMtL,GATF,QAYZkN,MAAO,KACPjE,MACIvM,MAAC2M,GAAkBJ,MAAOrC,GAAQmB,cAAeA,GAAevG,UAAWA,GAAhE,SAEfyD,OAAQ,KACRhH,OAAQ,KACRkP,UAAW,KACXC,KAAM,KACN3L,QAASA,EAAQvD,KAAI,SAACmP,EAAQrI,UAC1BtI,MAAC4Q,oBAEOD,GACJE,eAAgBvB,GAChBwB,gBAAiBvB,GACjBnP,KAAMuQ,EAAOvQ,MAAQqK,GACrBvJ,MAAOA,GACPyJ,YAAagG,EAAOhG,YAAcA,QAAcoG,cANjCzI,OAWrB0I,GAAYC,WAASxK,EAAMyD,GAAQxD,UAErCjC,IACAqL,GAAUU,MACNxQ,MAACqM,GAEGf,cAAeA,GACf5G,YAAaA,EACbC,cAAeA,EACf4H,MAAOrC,IAJH,UASZjF,IAAkC,IAAjBE,KACjB2K,GAAUvH,OACNvI,MAAC4N,GAEGrF,OAAQA,GACRtH,KAAMkE,GACN0H,MAAOzH,GACPsC,OAAQ6H,GACR5N,QAAS0D,GACTwI,QAAS+B,GACT7C,WAAY8C,IAPR,WAYZjM,IACAkM,GAAUvO,OACNvB,MAAC8N,GAEGvM,OAAQA,GACRwM,OAAQlK,EACRmK,KAAMlK,EACNtD,MAAO+I,GACP0E,YAAahK,EACbkH,YAAa1B,GACbyE,YAAa/J,EACbiG,MAAOhG,EACP+J,aAAciB,GATV,WAcZnK,GAAiBK,KACI,OAAjBoK,KACAI,GAAUW,UACNzQ,MAACkR,aAEGzJ,MAAO6H,GACP5H,OAAQ6H,GACRjN,EAAGoN,GAAapN,EAChBG,EAAGiN,GAAajN,EAChBuD,KAAMT,IALF,cASK,OAAjBqK,KACAE,GAAUW,UACNzQ,MAACkR,aAEGzJ,MAAO6H,GACP5H,OAAQ6H,GACRjN,EAAGsN,GAAatN,EAChBG,EAAGmN,GAAanN,EAChBuD,KAAMb,IALF,eAWhBF,GAAiBS,IAA4B,IAAjBP,KAC5B2K,GAAUY,KACN1Q,MAACwO,GAEGjN,OAAQA,GACRkG,MAAO6H,GACP5H,OAAQ6H,GACRd,OAAQA,GACRZ,QAAS6B,GACT3C,WAAY4C,GACZlC,aAAcA,GACdC,YAAaA,GACbC,aAAcA,GACde,QAASA,GACT/M,QAASA,GACTkL,MAAO3H,IAZH,SAkBZlF,MAACmR,cACG1K,KAAMuK,GACNvJ,MAAO+H,GACP9H,OAAQ+H,GACRhB,OAAQA,GACRhJ,KAAMA,YAEL1C,EAAOvB,KAAI,SAAC4P,EAAO9I,SACK,mBAAV8I,EAEHpR,MAACqR,qBACID,OACMlC,GACHI,WAAAA,GACAC,YAAAA,GACArF,OAAAA,GACA3B,OAAAA,GACAhH,OAAAA,GACAmB,OAAAA,GACAG,OAAAA,GACAwI,cAAAA,GACAC,cAAAA,GACAoE,aAAAA,GACAC,gBAAAA,GACAC,aAAAA,GACAC,gBAAAA,OAfOvH,GAqBhBwH,GAAUsB,SAMjCnC,EAAKvO,UAAY8E,EACjByJ,EAAKqC,aAAehL,QAELiL,gBAActC,GCpTvBuC,EAAa,gBACf/J,IAAAA,MACAC,IAAAA,OACQyH,IAARV,OACA3I,IAAAA,WAEA1F,IAAAA,KACQ2I,IAARrG,OACAC,IAAAA,QACQqG,IAARnG,OACAC,IAAAA,QACAE,IAAAA,MAEAD,IAAAA,OAEAwB,IAAAA,OACAO,IAAAA,UAEAL,IAAAA,WACAI,IAAAA,kBACAH,IAAAA,YAEAd,IAAAA,aACAE,IAAAA,UACAC,IAAAA,WACAE,IAAAA,iBACAC,IAAAA,iBAEAX,IAAAA,YACAG,IAAAA,YACAD,IAAAA,YACAE,IAAAA,YACAT,IAAAA,QACAE,IAAAA,UACAC,IAAAA,WACAC,IAAAA,SAEAyB,IAAAA,QAEAE,IAAAA,cACAC,IAAAA,UAGAyI,IAAAA,aACAe,IAAAA,QACA/M,IAAAA,QAEA8P,IAAAA,UAEMC,EAAWC,SAAO,QAC6CtC,gBACjE5H,EACAC,EACAyH,GAHIV,IAAAA,OAAQa,IAAAA,WAAYC,IAAAA,YAAaC,IAAAA,WAAYC,IAAAA,YAK/CvO,EAAQC,gBAC0BuI,WAAS,MAA1CgG,SAAcC,YAEoD7G,EAAQ,CAC7E1I,KAAAA,EACAsC,OAAQqG,EACRpG,QAAAA,EACAE,OAAQmG,EACRlG,QAAAA,EACA2E,MAAO6H,EACP5H,OAAQ6H,EACRhL,OAAAA,EACAvB,MAAAA,EACA6B,kBAAAA,EACAd,WAAAA,EACAG,iBAAAA,IAZImH,MAAAA,cAAeC,MAAAA,cAAepB,MAAAA,OAAQxH,MAAAA,OAAQG,MAAAA,OAAQtB,MAAAA,UAehCqQ,iBAAe,CACzCrQ,OAAAA,GACAkG,MAAO6H,EACP5H,OAAQ6H,EACR1C,MAAO3H,IAJH2M,MAAAA,SAAUC,MAAAA,QAOlBC,aAAU,WACFN,IACAA,EAAU5D,QAAU6D,EAAS7D,SAGjC6D,EAAS7D,QAAQpG,MAAQ+H,EAAa1J,EACtC4L,EAAS7D,QAAQnG,OAAS+H,EAAc3J,MAElCkM,EAAMN,EAAS7D,QAAQoE,WAAW,MAExCD,EAAIE,MAAMpM,EAAYA,GAEtBkM,EAAIG,UAAYjR,EAAMkR,WACtBJ,EAAIK,SAAS,EAAG,EAAG7C,EAAYC,GAC/BuC,EAAIM,UAAU7D,EAAOG,KAAMH,EAAOI,KAElC9L,EAAO6E,SAAQ,SAAAwJ,MACU,mBAAVA,GACPA,EAAM,CACFY,IAAAA,EACA1C,WAAAA,EACAC,YAAAA,EACArF,OAAAA,GACA3I,OAAAA,GACAmB,OAAAA,GACAG,OAAAA,GACAiC,UAAAA,EACAuG,cAAAA,GACAC,cAAAA,GACAoE,aAAAA,GACAC,gBAAAA,KAIM,SAAVyB,GAAoBlQ,EAAM6O,KAAK/I,KAAKmF,YAAc,IAClD6F,EAAIlN,UAAY5D,EAAM6O,KAAK/I,KAAKmF,YAChC6F,EAAIO,YAAcrR,EAAM6O,KAAK/I,KAAK0F,OAElCnJ,GACIiP,0BAAwBR,EAAK,CACzBvK,MAAO6H,EACP5H,OAAQ6H,EACR2C,MAAOxP,GACPzB,KAAM,IACNwR,OAAQ/O,IAGhBD,GACI+O,0BAAwBR,EAAK,CACzBvK,MAAO6H,EACP5H,OAAQ6H,EACR2C,MAAOrP,GACP5B,KAAM,IACNwR,OAAQ9O,KAIN,SAAVyN,GACAsB,qBAAmBV,EAAK,CACpBtP,OAAAA,GACAG,OAAAA,GACA4E,MAAO6H,EACP5H,OAAQ6H,EACRV,IAAK3L,EACLoN,MAAOlN,EACPmN,OAAQlN,EACRuL,KAAMtL,EACNpC,MAAAA,IAIM,UAAVkQ,IAAoC,IAAf3M,IACrBuN,EAAIW,OACJX,EAAIY,YAAclO,EAElB4G,GAAcuH,QAAQb,GACtB9H,GAAOtC,SAAQ,SAAA2C,GACXyH,EAAIG,UAAY5H,EAAM/J,MACtBwR,EAAIc,YACJxH,GAAcf,EAAMnK,KAAKoB,KAAI,SAAA0F,UAAKA,EAAE8D,aACpCgH,EAAItL,UAGRsL,EAAIe,WAGM,UAAV3B,IACA/F,GAAcwH,QAAQb,GACtB9H,GAAOtC,SAAQ,SAAA2C,GACXyH,EAAIO,YAAchI,EAAM/J,MACxBwR,EAAIlN,UAAYA,EAChBkN,EAAIc,YACJzH,GAAcd,EAAMnK,KAAKoB,KAAI,SAAA0F,UAAKA,EAAE8D,aACpCgH,EAAItF,aAIE,WAAV0E,IAAuC,IAAjBxN,GAAyBE,EAAY,GAC3DvC,GAAOqG,SAAQ,SAAA7H,GACXiS,EAAIG,UAAYpS,EAAMS,MACtBwR,EAAIc,YACJd,EAAIgB,IAAIjT,EAAMuC,EAAGvC,EAAM0C,EAAGqB,EAAY,EAAG,EAAG,EAAImP,KAAKC,IACrDlB,EAAItL,OAEAzC,EAAmB,IACnB+N,EAAIO,YAAcxS,EAAMoL,YACxB6G,EAAIlN,UAAYb,EAChB+N,EAAItF,aAKF,SAAV0E,IAAkC,IAAdlM,IACpBiO,wBAAsBnB,EAAKF,IACvBpC,IACA0D,4BAA0BpB,EAAKF,GAASpC,GAAazE,QAI/C,YAAVmG,EAAqB,KACf3G,EAAaP,GACd1I,KAAI,SAAA+I,SAAU,CACXrK,GAAIqK,EAAMrK,GACVkK,MAAOG,EAAMrK,GACbM,MAAO+J,EAAM/J,UAEhBoI,UAEL7D,EAAQ6C,SAAQ,SAAA+I,GACZ0C,uBAAqBrB,OACdrB,GACHvQ,KAAMuQ,EAAOvQ,MAAQqK,EACrBoG,eAAgBvB,EAChBwB,gBAAiBvB,EACjBrO,MAAAA,cAKjB,CACCwQ,EACAlC,EACAC,EACA1M,EACA7B,EACAmK,GACAnB,GACAxH,GACAG,GACAU,EACAG,EACAD,EACAE,EACAT,EACAE,EACAC,EACAC,EACAyB,EACAxD,GACAqC,EACAE,EACA4L,SAGE4D,GAAyB1I,eAC3B,SAAAwC,SACmBmG,oBAAkB7B,EAAS7D,QAAST,GAA5C9K,OAAGG,WACL+Q,iBAAe/E,EAAOG,KAAMH,EAAOI,IAAKS,EAAYC,EAAajN,EAAGG,GAAI,OAAO,SAE9EgR,EAAa5B,GAASvH,KAAKhI,EAAImM,EAAOG,KAAMnM,EAAIgM,EAAOI,YACtDtN,GAAOkS,KAElB,CAAC/B,EAAUjD,EAAQa,EAAYC,EAAasC,QAGF7E,eAAtCC,MAAAA,qBAAsBC,MAAAA,YAExBwG,GAAmB9I,eACrB,SAAAwC,OACUrN,EAAQuT,GAAuBlG,GACrCuC,GAAgB5P,GAEZA,EACAkN,GAAqBI,gBAAc1L,EAAS,CAAE5B,MAAAA,IAAUqN,GAExDF,OAGR,CAACoG,GAAwB3D,GAAiB1C,GAAsBC,GAAavL,IAG3E4L,GAAmB3C,eACrB,SAAAwC,GACIF,KACAyC,GAAgB,MAChBD,IAAgB/B,GAAgBA,EAAa+B,GAActC,KAE/D,CAACF,GAAayC,GAAiBhC,IAG7BmB,GAAclE,eAChB,SAAAwC,MACQsB,EAAS,KACH3O,EAAQuT,GAAuBlG,GACrCrN,GAAS2O,EAAQ3O,EAAOqN,MAGhC,CAACkG,GAAwB5E,WAIzB1O,gBACI2T,IAAKjC,EACLjK,MAAO+H,EAAa1J,EACpB4B,OAAQ+H,EAAc3J,EACtBpE,MAAO,CACH+F,MAAO+H,EACP9H,OAAQ+H,EACRmE,OAAQ3O,EAAgB,OAAS,UAErCwI,aAAcxI,EAAgByO,QAAmB3C,EACjDrD,YAAazI,EAAgByO,QAAmB3C,EAChDpD,aAAc1I,EAAgBsI,QAAmBwD,EACjDrC,QAASzJ,EAAgB6J,QAAciC,KAKnDS,EAAW9Q,UAAYmF,EACvB2L,EAAWF,aAAe3K,EAE1B,IAAMkN,EAA0BtC,gBAAcC,KAE/BsC,cAAW,SAAC5E,EAAOyE,UAAQ3T,MAAC6T,OAA4B3E,GAAOuC,UAAWkC,UC9T1EG,cANc,SAAC5E,EAAOyE,UACjC3T,MAAC+T,8BACI,gBAAGtM,IAAAA,MAAOC,IAAAA,cAAa1H,MAACwR,KAAW/J,MAAOA,EAAOC,OAAQA,GAAYwH,GAAOyE,IAAKA,8ICHnE,SAAAzE,UACnBlP,MAAC+T,8BACI,gBAAGtM,IAAAA,MAAOC,IAAAA,cAAa1H,MAACiP,KAAKxH,MAAOA,EAAOC,OAAQA,GAAYwH"}